<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Desafio para Let√≠cia</title>

<!-- Romantic fonts -->
<link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg1: #fff0f6;
    --bg2: #fff7f0;
    --accent: #e75480;
    --accent2: #ff7fa3;
    --card: rgba(255,255,255,0.85);
    --glass: rgba(255,255,255,0.6);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: "Inter",system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient( circle at 10% 10%, #fffaf0 0%, #fff0f6 30%, #fff7f0 100%);
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
    color:#333;
  }

  .wrap{
    width:100%;
    max-width:820px;
    background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,250,252,0.85));
    border-radius:20px;
    box-shadow: 0 10px 30px rgba(231,81,128,0.12);
    padding:18px;
    overflow:hidden;
  }

  header{
    text-align:center;
    margin-bottom:10px;
  }

  h1{
    font-family:"Great Vibes", cursive;
    font-size:42px;
    margin:6px 0 0 0;
    color:var(--accent);
    letter-spacing:0.6px;
  }
  .subtitle{
    font-family:"Playfair Display",serif;
    color:#8b4b60;
    font-size:15px;
    margin-top:4px;
  }

  /* Intro screen */
  .intro{
    text-align:center;
    padding:18px;
  }
  .intro .card{
    background:var(--card);
    border-radius:14px;
    padding:18px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  }
  .intro p{
    font-size:18px;
    color:#4b2030;
    margin:0 0 12px 0;
  }
  .btn{
    display:inline-block;
    padding:12px 22px;
    border-radius:999px;
    border:none;
    background:linear-gradient(90deg,var(--accent),var(--accent2));
    color:white;
    font-weight:600;
    font-size:16px;
    box-shadow: 0 6px 18px rgba(231,81,128,0.25);
    cursor:pointer;
  }

  /* Game area */
  .game{
    display:none;
    padding:10px 8px 18px 8px;
  }

  .topbar{
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
    margin-bottom:12px;
  }
  .topbar .message{
    flex:1;
    padding:12px;
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,240,247,0.6));
    box-shadow: 0 4px 12px rgba(0,0,0,0.04);
    font-family:"Playfair Display",serif;
    color:#7a2340;
    font-size:15px;
  }
  .wordlist{
    min-width:160px;
    text-align:left;
    font-weight:600;
    font-size:14px;
    color:#6a2a3d;
    background:var(--glass);
    padding:10px;
    border-radius:12px;
    box-shadow: inset 0 -6px 12px rgba(255,255,255,0.2);
  }
  .wordlist b{display:block; font-family:"Playfair Display",serif; margin-bottom:6px; color:#8b2d4d; font-size:15px;}
  .wordlist ul{margin:0; padding:0 8px; list-style:none}
  .wordlist li{margin:6px 0; padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.5); text-transform:uppercase; font-size:13px; letter-spacing:0.6px;}

  /* grid */
  .board-wrap{
    display:flex;
    justify-content:center;
    margin-top:10px;
  }
  .board{
    width:min(92vw,520px);
    height:min(92vw,520px);
    max-width:520px;
    max-height:520px;
    background: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,245,247,0.9));
    border-radius:18px;
    padding:10px;
    display:grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap:6px;
    touch-action: none;
    user-select:none;
  }
  .cell{
    background: linear-gradient(180deg,#fff,#ffeef6);
    border-radius:10px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    font-size:clamp(16px,3.4vw,26px);
    color:#8b2850;
    box-shadow: 0 4px 8px rgba(138,49,83,0.08), inset 0 -6px 12px rgba(255,255,255,0.6);
    -webkit-tap-highlight-color: transparent;
  }
  .cell.highlight{ background: linear-gradient(90deg,#ffe6f3,#fff0f6); transform:scale(0.975); }
  .cell.found{ background: linear-gradient(90deg,#ffdfe8,#ffd1e2); color:#4b1b30; box-shadow:none; transform:none; opacity:0.95; }

  /* phrase display */
  .phrase{
    margin-top:12px;
    text-align:center;
    padding:16px;
    border-radius:14px;
    background: linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,245,247,0.9));
    font-family:"Playfair Display",serif;
    font-size:18px;
    color:#6b1733;
    min-height:60px;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 8px 20px rgba(231,81,128,0.08);
  }

  /* scratch card modal */
  .overlay{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg, rgba(120,20,60,0.12), rgba(255,255,255,0.02));
    z-index:70;
    padding:24px;
    backdrop-filter: blur(4px);
  }
  .scratch-modal{
    width:min(96vw,520px);
    background: linear-gradient(180deg,#fff,#fff6fa);
    border-radius:16px;
    padding:16px;
    text-align:center;
    box-shadow: 0 12px 30px rgba(120,20,60,0.14);
  }
  .scratch-title{
    font-family:"Playfair Display",serif;
    color:#7a1f3a;
    font-size:18px;
    margin-bottom:10px;
  }
  .scratch-card{
    width:90%;
    max-width:420px;
    height:160px;
    margin:12px auto;
    border-radius:12px;
    position:relative;
    overflow:hidden;
    box-shadow: 0 8px 20px rgba(0,0,0,0.08);
    background: linear-gradient(90deg,#fff7f9,#fff1f6);
    display:flex;
    align-items:center;
    justify-content:center;
    font-family:"Great Vibes",cursive;
    font-size:22px;
    color:#9b1f46;
  }
  .scratch-instr{ font-size:13px; color:#6b2b42; margin-top:8px;}
  .close-btn{
    margin-top:12px;
    padding:10px 14px;
    border-radius:10px;
    border:none;
    background:transparent;
    color:#7a1f3a;
    cursor:pointer;
  }

  /* small hearts */
  .hearts{
    position:absolute;
    right:14px;
    top:14px;
    display:flex;
    gap:6px;
  }
  .heart{ width:12px; height:12px; background:var(--accent); border-radius:3px; transform:rotate(45deg); }

  @media (min-width:760px){
    h1{font-size:54px}
    .phrase{font-size:20px}
  }
</style>
</head>
<body>
<div class="wrap" id="app">
  <header>
    <h1>Let√≠cia ‚ô•</h1>
    <div class="subtitle">Um desafio com amor ‚Äî de Janu√°rio para voc√™</div>
  </header>

  <!-- INTRO -->
  <section class="intro" id="intro">
    <div class="card">
      <p style="font-size:18px;"><strong>Let√≠cia, complete este desafio e descubra o segredo do cadeado para ver o que tem na caixa</strong></p>
      <p style="margin:6px 0 12px 0; color:#7b2b43;">Toque em <strong>"Aceitar Desafio"</strong> quando estiver pronta ‚Äî arraste o dedo nas letras para formar palavras.</p>
      <button class="btn" id="startBtn">Aceitar Desafio</button>
    </div>
  </section>

  <!-- GAME -->
  <section class="game" id="game">
    <div class="topbar">
      <div class="message">Let√≠cia, encontre 6 palavras escolhidas pelo Janu√°rio e descubra a senha do cadeado.</div>
      <div class="wordlist">
        <b>Palavras</b>
        <ul id="wordList">
          <!-- filled by JS -->
        </ul>
      </div>
    </div>

    <div class="board-wrap">
      <div class="board" id="board" touch-action="none"></div>
    </div>

    <div class="phrase" id="phraseBox">Boa sorte, meu amor üíñ</div>
  </section>
</div>

<!-- Scratch modal (hidden initially) -->
<div id="scratchOverlay" class="overlay" style="display:none;">
  <div class="scratch-modal">
    <div class="scratch-title">Raspe aqui e descubra a senha do cadeado</div>
    <div class="scratch-card" id="scratchCard">
      <canvas id="scratchCanvas" width="600" height="240" style="width:90%; height:160px; border-radius:12px;"></canvas>
      <div id="scratchReveal" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; font-size:18px; color:#7a1f3a; font-family:'Playfair Display',serif;">
        Amor, a senha do cadeado √© <b>365</b>,<br> porque √© o numero de dias que quero passar com voc√™ em cada ano.
      </div>
    </div>
    <div class="scratch-instr">Raspe com o dedo at√© revelar a mensagem.</div>
    <button class="close-btn" id="closeScratch" style="display:none;">Fechar</button>
  </div>
</div>

<script>
/*
  Word search game with touch/mouse drag selection.
  - Words: Deus, Fam√≠lia, Amor, Respeito, Gratid√£o, Valores
  - Phrases to show on each found word (in this exact sequence, independent of which word):
    1) Voc√™ chegou e se tornou meu tudo
    2) Sou muito feliz por ter voc√™ comigo
    3) Obrigado por me fazer querer ser melhor
    4) S√≥ de estar ao seu lado me sinto muito bem
    5) Quero voc√™ comigo pro resto da minha vida
    6) Te amo
  - After finding all words, show scratch card.
*/

// Word & phrase definitions
const wordsOriginal = ["Deus", "Fam√≠lia", "Amor", "Respeito", "Gratid√£o", "Valores"];
// For placement/compare we will normalize (remove diacritics & uppercase)
function normalize(s){
  return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\s+/g,'').toUpperCase();
}
const words = wordsOriginal.map(normalize);

const displayWords = wordsOriginal; // show accentuated versions in list (as user wrote)

const phrases = [
  "Voc√™ chegou e se tornou meu tudo",
  "Sou muito feliz por ter voc√™ comigo",
  "Obrigado por me fazer querer ser melhor",
  "S√≥ de estar ao seu lado me sinto muito bem",
  "Quero voc√™ comigo pro resto da minha vida",
  "Te amo"
];

// grid size
const N = 8;
let grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>''));
const placed = []; // {word, coords: [{r,c},...]}
const directions = [
  [1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]
];

// Utility random
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

// Try to place a word on grid
function canPlace(word, r, c, dr, dc){
  for(let k=0;k<word.length;k++){
    const rr = r + k*dr;
    const cc = c + k*dc;
    if(rr<0||rr>=N||cc<0||cc>=N) return false;
    const cur = grid[rr][cc];
    if(cur && cur !== '' && cur !== word[k]) return false;
  }
  return true;
}
function placeWord(word){
  const attempts = 300;
  for(let t=0;t<attempts;t++){
    const dir = directions[randInt(0,directions.length-1)];
    const dr = dir[0], dc = dir[1];
    const maxR = dr===1 ? N - word.length : (dr===-1 ? word.length-1 : N-1);
    const minR = dr===-1 ? word.length-1 : 0;
    const r = randInt(minR, maxR);
    const maxC = dc===1 ? N - word.length : (dc===-1 ? word.length-1 : N-1);
    const minC = dc===-1 ? word.length-1 : 0;
    const c = randInt(minC, maxC);
    if(canPlace(word,r,c,dr,dc)){
      const coords = [];
      for(let k=0;k<word.length;k++){
        const rr = r + k*dr;
        const cc = c + k*dc;
        grid[rr][cc] = word[k];
        coords.push({r:rr,c:cc});
      }
      placed.push({word, coords});
      return true;
    }
  }
  return false;
}

// Fill rest with random letters
function fillRandom(){
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for(let i=0;i<N;i++){
    for(let j=0;j<N;j++){
      if(!grid[i][j] || grid[i][j]==='') grid[i][j] = letters.charAt(randInt(0,letters.length-1));
    }
  }
}

// Build board by placing words randomly
function buildBoard(){
  // reset
  grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>''));
  placed.length = 0;
  // attempt to place each word (try multiple times if fail; if fail, try again overall)
  let success=false;
  for(let tries=0; tries<6 && !success; tries++){
    grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>''));
    placed.length = 0;
    let ok=true;
    // place longer words first to help fit
    const sorted = words.slice().sort((a,b)=>b.length-a.length);
    for(const w of sorted){
      if(!placeWord(w)) { ok=false; break; }
    }
    if(ok){
      fillRandom();
      success=true;
    }
  }
  if(!success){
    // fallback: place in simple manner horizontally top rows (shouldn't usually happen)
    grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>'A'));
    placed.length=0;
    let r=0;
    for(const w of words){
      for(let k=0;k<w.length;k++){
        grid[r][k] = w[k];
      }
      const coords = [];
      for(let k=0;k<w.length;k++) coords.push({r:r,c:k});
      placed.push({word:w, coords});
      r = (r+1)%N;
    }
    fillRandom();
  }
}

// Render board to DOM
const boardEl = document.getElementById('board');
function renderBoard(){
  boardEl.innerHTML='';
  for(let i=0;i<N;i++){
    for(let j=0;j<N;j++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = i;
      cell.dataset.c = j;
      cell.textContent = grid[i][j];
      boardEl.appendChild(cell);
    }
  }
}

// Word list UI
function renderWordList(){
  const ul = document.getElementById('wordList');
  ul.innerHTML='';
  for(const w of displayWords){
    const li = document.createElement('li');
    li.textContent = w;
    ul.appendChild(li);
  }
}

// Selection logic
let selecting = false;
let startCell = null;
let currentHighlights = [];
let foundWords = new Set();
let findOrderIndex = 0; // which phrase to show next
const phraseBox = document.getElementById('phraseBox');

function coordsEqual(a,b){ return a.r===b.r && a.c===b.c; }
function cellElem(r,c){
  return boardEl.querySelector('.cell[data-r="'+r+'"][data-c="'+c+'"]');
}
function clearHighlights(){
  currentHighlights.forEach(({r,c})=>{
    const e = cellElem(r,c);
    if(e && !e.classList.contains('found')) e.classList.remove('highlight');
  });
  currentHighlights = [];
}

function highlightLine(start, end){
  clearHighlights();
  const dr = end.r - start.r;
  const dc = end.c - start.c;
  const steps = Math.max(Math.abs(dr), Math.abs(dc));
  if(steps===0){
    currentHighlights.push(start);
    const e = cellElem(start.r,start.c);
    if(e) e.classList.add('highlight');
    return;
  }
  const stepR = dr/steps;
  const stepC = dc/steps;
  if(Math.abs(Math.round(stepR)-stepR) > 1e-6 || Math.abs(Math.round(stepC)-stepC) > 1e-6){
    return;
  }
  const sr = Math.sign(stepR);
  const sc = Math.sign(stepC);
  for(let k=0;k<=steps;k++){
    const rr = Math.round(start.r + k*stepR);
    const cc = Math.round(start.c + k*stepC);
    if(rr<0||rr>=N||cc<0||cc>=N) break;
    currentHighlights.push({r:rr,c:cc});
    const e = cellElem(rr,cc);
    if(e && !e.classList.contains('found')) e.classList.add('highlight');
  }
}

function getHighlightedWord(){
  if(currentHighlights.length===0) return '';
  let s = '';
  for(const {r,c} of currentHighlights){
    s += grid[r][c];
  }
  return s;
}

function checkMatch(){
  const s = getHighlightedWord();
  if(!s) return null;
  const idx = placed.findIndex(p => {
    if(foundWords.has(p.word)) return false;
    const w = p.word;
    if(w === s) return true;
    if(w.split('').reverse().join('') === s) return true;
    return false;
  });
  if(idx>=0) return placed[idx];
  return null;
}

function markFound(found){
  for(const {r,c} of found.coords){
    const e = cellElem(r,c);
    if(e){ e.classList.add('found'); e.classList.remove('highlight'); }
  }
  foundWords.add(found.word);
  if(findOrderIndex < phrases.length){
    phraseBox.innerHTML = '<div style="font-size:20px;">' + phrases[findOrderIndex] + '</div>';
    findOrderIndex++;
  }

  const normalized = found.word;
  const lis = document.querySelectorAll('#wordList li');
  lis.forEach(li=>{
    const liText = li.textContent || '';
    if(normalize(liText) === normalized){
      li.style.textDecoration = 'line-through';
      li.style.opacity = '0.7';
    }
  });

  if(foundWords.size >= words.length){
    setTimeout(()=> showScratch(), 700);
  }
}

// Event handling for touch & mouse
let pointerDown = false;
let startRC = null;

function toGridCoordsFromEvent(e){
  let clientX, clientY;
  if(e.touches && e.touches[0]){
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else if(e.changedTouches && e.changedTouches[0]){
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  const el = document.elementFromPoint(clientX, clientY);
  if(!el) return null;
  const cell = el.closest('.cell');
  if(!cell) return null;
  const r = parseInt(cell.dataset.r,10);
  const c = parseInt(cell.dataset.c,10);
  if(isNaN(r) || isNaN(c)) return null;
  return {r,c};
}

function handleStart(e){
  e.preventDefault();
  pointerDown = true;
  const p = toGridCoordsFromEvent(e);
  if(!p) return;
  startRC = p;
  startCell = p;
  highlightLine(startCell, startCell);
}

function handleMove(e){
  if(!pointerDown) return;
  const p = toGridCoordsFromEvent(e);
  if(!p) return;
  highlightLine(startCell, p);
}

function handleEnd(e){
  if(!pointerDown) return;
  pointerDown = false;
  const match = checkMatch();
  if(match){
    markFound(match);
  } else {
    clearHighlights();
  }
}

function attachEvents(){
  boardEl.addEventListener('touchstart', handleStart, {passive:false});
  boardEl.addEventListener('touchmove', handleMove, {passive:false});
  boardEl.addEventListener('touchend', handleEnd, {passive:false});
  boardEl.addEventListener('mousedown', function(e){ handleStart(e); });
  window.addEventListener('mousemove', function(e){ handleMove(e); });
  window.addEventListener('mouseup', function(e){ handleEnd(e); });

  boardEl.addEventListener('click', function(e){
    const cell = e.target.closest('.cell');
    if(!cell) return;
    const r = parseInt(cell.dataset.r,10);
    const c = parseInt(cell.dataset.c,10);
    startCell = {r,c};
    highlightLine(startCell,startCell);
    const match = checkMatch();
    if(match) markFound(match);
    else setTimeout(()=>clearHighlights(),350);
  });
}

document.getElementById('startBtn').addEventListener('click', ()=>{
  document.getElementById('intro').style.display='none';
  document.getElementById('game').style.display='block';
  buildBoard();
  renderBoard();
  renderWordList();
  attachEvents();
  phraseBox.innerHTML = 'Encontre as palavras arrastando o dedo sobre as letras. Boa sorte, Let√≠cia üíù';
});

// Scratch card implementation
const scratchOverlay = document.getElementById('scratchOverlay');
const scratchCanvas = document.getElementById('scratchCanvas');
const scratchCtx = scratchCanvas.getContext('2d');
let scratching = false;

function showScratch(){
  scratchOverlay.style.display='flex';
  const el = scratchCanvas;
  const style = getComputedStyle(el);
  scratchCtx.clearRect(0,0,el.width,el.height);
  scratchCtx.fillStyle = '#bdbdbd';
  scratchCtx.fillRect(0,0,el.width,el.height);
  scratchCtx.fillStyle = '#7a7a7a';
  scratchCtx.font = Math.floor(el.width/12) + "px sans-serif";
  scratchCtx.textAlign='center';
  scratchCtx.fillText("Raspe aqui", el.width/2, el.height/2);
  scratchCtx.globalCompositeOperation = 'destination-out';
  document.getElementById('closeScratch').style.display='none';
}

function scratchStart(e){
  scratching=true;
  scratchMove(e);
}
function scratchEnd(e){
  scratching=false;
  const el = scratchCanvas;
  const image = scratchCtx.getImageData(0,0,el.width,el.height);
  let cleared = 0;
  for(let i=3;i<image.data.length;i+=4){
    if(image.data[i] === 0) cleared++;
  }
  const total = el.width*el.height;
  const ratio = cleared/total;
  if(ratio > 0.25){
    scratchCtx.clearRect(0,0,el.width,el.height);
    document.getElementById('closeScratch').style.display='inline-block';
  }
}
function scratchMove(e){
  if(!scratching) return;
  e.preventDefault();
  let clientX, clientY;
  if(e.touches && e.touches[0]){ clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
  else { clientX = e.clientX; clientY = e.clientY; }
  const rect = scratchCanvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (scratchCanvas.width / rect.width);
  const y = (clientY - rect.top) * (scratchCanvas.height / rect.height);
  scratchCtx.beginPath();
  scratchCtx.arc(x,y,28,0,Math.PI*2);
  scratchCtx.fill();
}

scratchCanvas.addEventListener('touchstart', scratchStart, {passive:false});
scratchCanvas.addEventListener('touchmove', scratchMove, {passive:false});
scratchCanvas.addEventListener('touchend', scratchEnd, {passive:false});
scratchCanvas.addEventListener('mousedown', (e)=>{ scratching=true; scratchMove(e); });
window.addEventListener('mousemove', scratchMove);
window.addEventListener('mouseup', (e)=>{ if(scratching){ scratching=false; scratchEnd(e); } });

document.getElementById('closeScratch').addEventListener('click', ()=>{
  scratchOverlay.style.display='none';
  phraseBox.innerHTML = '<div style="font-size:20px;">Amor, o meu pr√™mio √© voc√™. ‚ù§Ô∏è</div>';
});
</script>
</body>
</html>
