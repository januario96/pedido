<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Desafio para Letícia</title>

<!-- Romantic fonts -->
<link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg1: #fff0f6;
    --bg2: #fff7f0;
    --accent: #e75480;
    --accent2: #ff7fa3;
    --card: rgba(255,255,255,0.85);
    --glass: rgba(255,255,255,0.6);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: "Inter",system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient( circle at 10% 10%, #fffaf0 0%, #fff0f6 30%, #fff7f0 100%);
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
    color:#333;
  }

  .wrap{
    width:100%;
    max-width:820px;
    background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,250,252,0.85));
    border-radius:20px;
    box-shadow: 0 10px 30px rgba(231,81,128,0.12);
    padding:18px;
    overflow:hidden;
  }

  header{
    text-align:center;
    margin-bottom:10px;
  }

  h1{
    font-family:"Great Vibes", cursive;
    font-size:42px;
    margin:6px 0 0 0;
    color:var(--accent);
    letter-spacing:0.6px;
  }
  .subtitle{
    font-family:"Playfair Display",serif;
    color:#8b4b60;
    font-size:15px;
    margin-top:4px;
  }

  /* Intro screen */
  .intro{
    text-align:center;
    padding:18px;
  }
  .intro .card{
    background:var(--card);
    border-radius:14px;
    padding:18px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.06);
  }
  .intro p{
    font-size:18px;
    color:#4b2030;
    margin:0 0 12px 0;
  }
  .btn{
    display:inline-block;
    padding:12px 22px;
    border-radius:999px;
    border:none;
    background:linear-gradient(90deg,var(--accent),var(--accent2));
    color:white;
    font-weight:600;
    font-size:16px;
    box-shadow: 0 6px 18px rgba(231,81,128,0.25);
    cursor:pointer;
  }

  /* Game area */
  .game{
    display:none;
    padding:10px 8px 18px 8px;
  }

  .topbar{
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
    margin-bottom:12px;
  }
  .topbar .message{
    flex:1;
    padding:12px;
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,240,247,0.6));
    box-shadow: 0 4px 12px rgba(0,0,0,0.04);
    font-family:"Playfair Display",serif;
    color:#7a2340;
    font-size:15px;
  }
  .wordlist{
    min-width:160px;
    text-align:left;
    font-weight:600;
    font-size:14px;
    color:#6a2a3d;
    background:var(--glass);
    padding:10px;
    border-radius:12px;
    box-shadow: inset 0 -6px 12px rgba(255,255,255,0.2);
  }
  .wordlist b{display:block; font-family:"Playfair Display",serif; margin-bottom:6px; color:#8b2d4d; font-size:15px;}
  .wordlist ul{margin:0; padding:0 8px; list-style:none}
  .wordlist li{margin:6px 0; padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.5); text-transform:uppercase; font-size:13px; letter-spacing:0.6px;}

  /* grid */
  .board-wrap{
    display:flex;
    justify-content:center;
    margin-top:10px;
  }
  .board{
    width:min(92vw,520px);
    height:min(92vw,520px);
    max-width:520px;
    max-height:520px;
    background: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,245,247,0.9));
    border-radius:18px;
    padding:10px;
    display:grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap:6px;
    touch-action: none;
    user-select:none;
  }
  .cell{
    background: linear-gradient(180deg,#fff,#ffeef6);
    border-radius:10px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    font-size:clamp(16px,3.4vw,26px);
    color:#8b2850;
    box-shadow: 0 4px 8px rgba(138,49,83,0.08), inset 0 -6px 12px rgba(255,255,255,0.6);
    -webkit-tap-highlight-color: transparent;
  }
  .cell.highlight{ background: linear-gradient(90deg,#ffe6f3,#fff0f6); transform:scale(0.975); }
  .cell.found{ background: linear-gradient(90deg,#ffdfe8,#ffd1e2); color:#4b1b30; box-shadow:none; transform:none; opacity:0.95; }

  /* phrase display */
  .phrase{
    margin-top:12px;
    text-align:center;
    padding:16px;
    border-radius:14px;
    background: linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,245,247,0.9));
    font-family:"Playfair Display",serif;
    font-size:18px;
    color:#6b1733;
    min-height:60px;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 8px 20px rgba(231,81,128,0.08);
  }

  /* scratch card modal */
  .overlay{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg, rgba(120,20,60,0.12), rgba(255,255,255,0.02));
    z-index:70;
    padding:24px;
    backdrop-filter: blur(4px);
  }
  .scratch-modal{
    width:min(96vw,520px);
    background: linear-gradient(180deg,#fff,#fff6fa);
    border-radius:16px;
    padding:16px;
    text-align:center;
    box-shadow: 0 12px 30px rgba(120,20,60,0.14);
  }
  .scratch-title{
    font-family:"Playfair Display",serif;
    color:#7a1f3a;
    font-size:18px;
    margin-bottom:10px;
  }
  .scratch-card{
    width:90%;
    max-width:420px;
    height:160px;
    margin:12px auto;
    border-radius:12px;
    position:relative;
    overflow:hidden;
    box-shadow: 0 8px 20px rgba(0,0,0,0.08);
    background: linear-gradient(90deg,#fff7f9,#fff1f6);
    display:flex;
    align-items:center;
    justify-content:center;
    font-family:"Great Vibes",cursive;
    font-size:22px;
    color:#9b1f46;
  }
  .scratch-instr{ font-size:13px; color:#6b2b42; margin-top:8px;}
  .close-btn{
    margin-top:12px;
    padding:10px 14px;
    border-radius:10px;
    border:none;
    background:transparent;
    color:#7a1f3a;
    cursor:pointer;
  }

  /* small hearts */
  .hearts{
    position:absolute;
    right:14px;
    top:14px;
    display:flex;
    gap:6px;
  }
  .heart{ width:12px; height:12px; background:var(--accent); border-radius:3px; transform:rotate(45deg); }

  @media (min-width:760px){
    h1{font-size:54px}
    .phrase{font-size:20px}
  }
</style>
</head>
<body>
<div class="wrap" id="app">
  <header>
    <h1>Letícia ♥</h1>
    <div class="subtitle">Um desafio com amor — de Januário para você</div>
  </header>

  <!-- INTRO -->
  <section class="intro" id="intro">
    <div class="card">
      <p style="font-size:18px;"><strong>Letícia, complete este desafio e descubra o segredo do cadeado para ver o que tem na caixa</strong></p>
      <p style="margin:6px 0 12px 0; color:#7b2b43;">Toque em <strong>"Aceitar Desafio"</strong> quando estiver pronta — arraste o dedo nas letras para formar palavras.</p>
      <button class="btn" id="startBtn">Aceitar Desafio</button>
    </div>
  </section>

  <!-- GAME -->
  <section class="game" id="game">
    <div class="topbar">
      <div class="message">Letícia, encontre 6 palavras escolhidas pelo Januário e descubra a senha do cadeado.</div>
      <div class="wordlist">
        <b>Palavras</b>
        <ul id="wordList">
          <!-- filled by JS -->
        </ul>
      </div>
    </div>

    <div class="board-wrap">
      <div class="board" id="board" touch-action="none"></div>
    </div>

    <div class="phrase" id="phraseBox">Boa sorte, meu amor 💖</div>
  </section>
</div>

<!-- Scratch modal (hidden initially) -->
<div id="scratchOverlay" class="overlay" style="display:none;">
  <div class="scratch-modal">
    <div class="scratch-title">Raspe aqui e descubra a senha do cadeado</div>
    <div class="scratch-card" id="scratchCard">
      <canvas id="scratchCanvas" width="600" height="240" style="width:90%; height:160px; border-radius:12px;"></canvas>
      <div id="scratchReveal" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; font-size:18px; color:#7a1f3a; font-family:'Playfair Display',serif;">
        Amor, a senha do cadeado é <b>365</b>,<br> porque é o numero de dias que quero passar com você em cada ano.
      </div>
    </div>
    <div class="scratch-instr">Raspe com o dedo até revelar a mensagem.</div>
    <button class="close-btn" id="closeScratch" style="display:none;">Fechar</button>
  </div>
</div>

<script>
/*
  Word search game with touch/mouse drag selection.
  - Words: Deus, Família, Amor, Respeito, Gratidão, Valores
  - Phrases to show on each found word (in this exact sequence, independent of which word):
    1) Você chegou e se tornou meu tudo
    2) Sou muito feliz por ter você comigo
    3) Obrigado por me fazer querer ser melhor
    4) Só de estar ao seu lado me sinto muito bem
    5) Quero você comigo pro resto da minha vida
    6) Te amo
  - After finding all words, show scratch card.
*/

// Word & phrase definitions
const wordsOriginal = ["Deus", "Família", "Amor", "Respeito", "Gratidão", "Valores"];
// For placement/compare we will normalize (remove diacritics & uppercase)
function normalize(s){
  return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\s+/g,'').toUpperCase();
}
const words = wordsOriginal.map(normalize);

const displayWords = wordsOriginal; // show accentuated versions in list (as user wrote)

const phrases = [
  "Você chegou e se tornou meu tudo",
  "Sou muito feliz por ter você comigo",
  "Obrigado por me fazer querer ser melhor",
  "Só de estar ao seu lado me sinto muito bem",
  "Quero você comigo pro resto da minha vida",
  "Te amo"
];

// grid size
const N = 8;
let grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>''));
const placed = []; // {word, coords: [{r,c},...]}
const directions = [
  [1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]
];

// Utility random
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

// Try to place a word on grid
function canPlace(word, r, c, dr, dc){
  for(let k=0;k<word.length;k++){
    const rr = r + k*dr;
    const cc = c + k*dc;
    if(rr<0||rr>=N||cc<0||cc>=N) return false;
    const cur = grid[rr][cc];
    if(cur && cur !== '' && cur !== word[k]) return false;
  }
  return true;
}
function placeWord(word){
  const attempts = 300;
  for(let t=0;t<attempts;t++){
    const dir = directions[randInt(0,directions.length-1)];
    const dr = dir[0], dc = dir[1];
    const maxR = dr===1 ? N - word.length : (dr===-1 ? word.length-1 : N-1);
    const minR = dr===-1 ? word.length-1 : 0;
    const r = randInt(minR, maxR);
    const maxC = dc===1 ? N - word.length : (dc===-1 ? word.length-1 : N-1);
    const minC = dc===-1 ? word.length-1 : 0;
    const c = randInt(minC, maxC);
    if(canPlace(word,r,c,dr,dc)){
      const coords = [];
      for(let k=0;k<word.length;k++){
        const rr = r + k*dr;
        const cc = c + k*dc;
        grid[rr][cc] = word[k];
        coords.push({r:rr,c:cc});
      }
      placed.push({word, coords});
      return true;
    }
  }
  return false;
}

// Fill rest with random letters
function fillRandom(){
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for(let i=0;i<N;i++){
    for(let j=0;j<N;j++){
      if(!grid[i][j] || grid[i][j]==='') grid[i][j] = letters.charAt(randInt(0,letters.length-1));
    }
  }
}

// Build board by placing words randomly
function buildBoard(){
  // reset
  grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>''));
  placed.length = 0;
  // attempt to place each word (try multiple times if fail; if fail, try again overall)
  let success=false;
  for(let tries=0; tries<6 && !success; tries++){
    grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>''));
    placed.length = 0;
    let ok=true;
    // place longer words first to help fit
    const sorted = words.slice().sort((a,b)=>b.length-a.length);
    for(const w of sorted){
      if(!placeWord(w)) { ok=false; break; }
    }
    if(ok){
      fillRandom();
      success=true;
    }
  }
  if(!success){
    // fallback: place in simple manner horizontally top rows (shouldn't usually happen)
    grid = Array.from({length:N}, ()=>Array.from({length:N}, ()=>'A'));
    placed.length=0;
    let r=0;
    for(const w of words){
      for(let k=0;k<w.length;k++){
        grid[r][k] = w[k];
      }
      const coords = [];
      for(let k=0;k<w.length;k++) coords.push({r:r,c:k});
      placed.push({word:w, coords});
      r = (r+1)%N;
    }
    fillRandom();
  }
}

// Render board to DOM
const boardEl = document.getElementById('board');
function renderBoard(){
  boardEl.innerHTML='';
  for(let i=0;i<N;i++){
    for(let j=0;j<N;j++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = i;
      cell.dataset.c = j;
      cell.textContent = grid[i][j];
      boardEl.appendChild(cell);
    }
  }
}

// Word list UI
function renderWordList(){
  const ul = document.getElementById('wordList');
  ul.innerHTML='';
  for(const w of displayWords){
    const li = document.createElement('li');
    li.textContent = w;
    ul.appendChild(li);
  }
}

// Selection logic
let selecting = false;
let startCell = null;
let currentHighlights = [];
let foundWords = new Set();
let findOrderIndex = 0; // which phrase to show next
const phraseBox = document.getElementById('phraseBox');

function coordsEqual(a,b){ return a.r===b.r && a.c===b.c; }
function cellElem(r,c){
  return boardEl.querySelector('.cell[data-r="'+r+'"][data-c="'+c+'"]');
}
function clearHighlights(){
  currentHighlights.forEach(({r,c})=>{
    const e = cellElem(r,c);
    if(e && !e.classList.contains('found')) e.classList.remove('highlight');
  });
  currentHighlights = [];
}

function highlightLine(start, end){
  clearHighlights();
  const dr = end.r - start.r;
  const dc = end.c - start.c;
  const steps = Math.max(Math.abs(dr), Math.abs(dc));
  if(steps===0){
    currentHighlights.push(start);
    const e = cellElem(start.r,start.c);
    if(e) e.classList.add('highlight');
    return;
  }
  const stepR = dr/steps;
  const stepC = dc/steps;
  if(Math.abs(Math.round(stepR)-stepR) > 1e-6 || Math.abs(Math.round(stepC)-stepC) > 1e-6){
    return;
  }
  const sr = Math.sign(stepR);
  const sc = Math.sign(stepC);
  for(let k=0;k<=steps;k++){
    const rr = Math.round(start.r + k*stepR);
    const cc = Math.round(start.c + k*stepC);
    if(rr<0||rr>=N||cc<0||cc>=N) break;
    currentHighlights.push({r:rr,c:cc});
    const e = cellElem(rr,cc);
    if(e && !e.classList.contains('found')) e.classList.add('highlight');
  }
}

function getHighlightedWord(){
  if(currentHighlights.length===0) return '';
  let s = '';
  for(const {r,c} of currentHighlights){
    s += grid[r][c];
  }
  return s;
}

function checkMatch(){
  const s = getHighlightedWord();
  if(!s) return null;
  const idx = placed.findIndex(p => {
    if(foundWords.has(p.word)) return false;
    const w = p.word;
    if(w === s) return true;
    if(w.split('').reverse().join('') === s) return true;
    return false;
  });
  if(idx>=0) return placed[idx];
  return null;
}

function markFound(found){
  for(const {r,c} of found.coords){
    const e = cellElem(r,c);
    if(e){ e.classList.add('found'); e.classList.remove('highlight'); }
  }
  foundWords.add(found.word);
  if(findOrderIndex < phrases.length){
    phraseBox.innerHTML = '<div style="font-size:20px;">' + phrases[findOrderIndex] + '</div>';
    findOrderIndex++;
  }

  const normalized = found.word;
  const lis = document.querySelectorAll('#wordList li');
  lis.forEach(li=>{
    const liText = li.textContent || '';
    if(normalize(liText) === normalized){
      li.style.textDecoration = 'line-through';
      li.style.opacity = '0.7';
    }
  });

  if(foundWords.size >= words.length){
    setTimeout(()=> showScratch(), 700);
  }
}

// Event handling for touch & mouse
let pointerDown = false;
let startRC = null;

function toGridCoordsFromEvent(e){
  let clientX, clientY;
  if(e.touches && e.touches[0]){
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else if(e.changedTouches && e.changedTouches[0]){
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  const el = document.elementFromPoint(clientX, clientY);
  if(!el) return null;
  const cell = el.closest('.cell');
  if(!cell) return null;
  const r = parseInt(cell.dataset.r,10);
  const c = parseInt(cell.dataset.c,10);
  if(isNaN(r) || isNaN(c)) return null;
  return {r,c};
}

function handleStart(e){
  e.preventDefault();
  pointerDown = true;
  const p = toGridCoordsFromEvent(e);
  if(!p) return;
  startRC = p;
  startCell = p;
  highlightLine(startCell, startCell);
}

function handleMove(e){
  if(!pointerDown) return;
  const p = toGridCoordsFromEvent(e);
  if(!p) return;
  highlightLine(startCell, p);
}

function handleEnd(e){
  if(!pointerDown) return;
  pointerDown = false;
  const match = checkMatch();
  if(match){
    markFound(match);
  } else {
    clearHighlights();
  }
}

function attachEvents(){
  boardEl.addEventListener('touchstart', handleStart, {passive:false});
  boardEl.addEventListener('touchmove', handleMove, {passive:false});
  boardEl.addEventListener('touchend', handleEnd, {passive:false});
  boardEl.addEventListener('mousedown', function(e){ handleStart(e); });
  window.addEventListener('mousemove', function(e){ handleMove(e); });
  window.addEventListener('mouseup', function(e){ handleEnd(e); });

  boardEl.addEventListener('click', function(e){
    const cell = e.target.closest('.cell');
    if(!cell) return;
    const r = parseInt(cell.dataset.r,10);
    const c = parseInt(cell.dataset.c,10);
    startCell = {r,c};
    highlightLine(startCell,startCell);
    const match = checkMatch();
    if(match) markFound(match);
    else setTimeout(()=>clearHighlights(),350);
  });
}

document.getElementById('startBtn').addEventListener('click', ()=>{
  document.getElementById('intro').style.display='none';
  document.getElementById('game').style.display='block';
  buildBoard();
  renderBoard();
  renderWordList();
  attachEvents();
  phraseBox.innerHTML = 'Encontre as palavras arrastando o dedo sobre as letras. Boa sorte, Letícia 💝';
});

// Scratch card implementation
const scratchOverlay = document.getElementById('scratchOverlay');
const scratchCanvas = document.getElementById('scratchCanvas');
const scratchCtx = scratchCanvas.getContext('2d');
let scratching = false;

function showScratch(){
  scratchOverlay.style.display='flex';
  const el = scratchCanvas;
  const style = getComputedStyle(el);
  scratchCtx.clearRect(0,0,el.width,el.height);
  scratchCtx.fillStyle = '#bdbdbd';
  scratchCtx.fillRect(0,0,el.width,el.height);
  scratchCtx.fillStyle = '#7a7a7a';
  scratchCtx.font = Math.floor(el.width/12) + "px sans-serif";
  scratchCtx.textAlign='center';
  scratchCtx.fillText("Raspe aqui", el.width/2, el.height/2);
  scratchCtx.globalCompositeOperation = 'destination-out';
  document.getElementById('closeScratch').style.display='none';
}

function scratchStart(e){
  scratching=true;
  scratchMove(e);
}
function scratchEnd(e){
  scratching=false;
  const el = scratchCanvas;
  const image = scratchCtx.getImageData(0,0,el.width,el.height);
  let cleared = 0;
  for(let i=3;i<image.data.length;i+=4){
    if(image.data[i] === 0) cleared++;
  }
  const total = el.width*el.height;
  const ratio = cleared/total;
  if(ratio > 0.25){
    scratchCtx.clearRect(0,0,el.width,el.height);
    document.getElementById('closeScratch').style.display='inline-block';
  }
}
function scratchMove(e){
  if(!scratching) return;
  e.preventDefault();
  let clientX, clientY;
  if(e.touches && e.touches[0]){ clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
  else { clientX = e.clientX; clientY = e.clientY; }
  const rect = scratchCanvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (scratchCanvas.width / rect.width);
  const y = (clientY - rect.top) * (scratchCanvas.height / rect.height);
  scratchCtx.beginPath();
  scratchCtx.arc(x,y,28,0,Math.PI*2);
  scratchCtx.fill();
}

scratchCanvas.addEventListener('touchstart', scratchStart, {passive:false});
scratchCanvas.addEventListener('touchmove', scratchMove, {passive:false});
scratchCanvas.addEventListener('touchend', scratchEnd, {passive:false});
scratchCanvas.addEventListener('mousedown', (e)=>{ scratching=true; scratchMove(e); });
window.addEventListener('mousemove', scratchMove);
window.addEventListener('mouseup', (e)=>{ if(scratching){ scratching=false; scratchEnd(e); } });

document.getElementById('closeScratch').addEventListener('click', ()=>{
  scratchOverlay.style.display='none';
  phraseBox.innerHTML = '<div style="font-size:20px;">Amor, o meu prêmio é você. ❤️</div>';
});
</script>
</body>
</html>
